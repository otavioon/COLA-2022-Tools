/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author edamat
 */

#include <bits/stdc++.h>
using namespace std;
#define _overload3(_1, _2, _3, name, ...) name
#define _rep(i, n) repi(i, 0, n)
#define repi(i, a, b) for(int i = int(a), i##_len = (b); i < i##_len; ++i)
#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)
#define _repr(i, n) repri(i, n, 0)
/* loop in [n,m] step -1 */
#define repri(i, a, b) for(int i = int(a), i##_len = (b); i >= i##_len; --i)
/* loop in [n,0] step -1 or [n,m] step -1 */
#define repr(...) _overload3(__VA_ARGS__, repri, _repr, )(__VA_ARGS__)
#define all(x) (x).begin(), (x).end()
#define debug(x) cerr << #x << ": " << (x) << '\n'
#define pb push_back
#define eb emplace_back
//#define endl '\n'
typedef long long lint;
// #define int lint
const int INF = (int)(1 << 30) - 1;
int MOD = (int)1e9 + 7;
const double EPS = 1e-9;
const lint LINF = (lint)(1LL << 62) - 1;
typedef vector<int> vint;
typedef pair<int, int> pint;

struct IoSetup {
    IoSetup() {
        cin.tie(nullptr);
        ios::sync_with_stdio(false);
//        cout << fixed << setprecision(20);
//        cerr << fixed << setprecision(20);
    }
} iosetup;

using std::to_string;
auto to_string(std::string s) -> std::string {
    return '"' + s + '"';
}
auto to_string(char c) -> std::string {
    return "'" + std::string{c} + "'";
}
auto to_string(const char* s) -> std::string {
    return to_string((std::string) s);
}
auto to_string(bool b) -> std::string {
    return (b ? "true" : "false");
}
template <typename T, typename U>
auto to_string(std::pair<T, U> p) -> std::string {
    return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
}
template <size_t N>
auto to_string(std::bitset<N> bs) -> std::string {
    std::string res{};
    for (size_t i = 0; i < N; i++)
        res.insert(res.begin(), bs.test(i) ? '1' : '0');
    return res;
}
template <typename T>
auto to_string(T v) -> std::string {
    bool flg = false;
    std::string res = "[";
    for (auto const&x : v) {
        if (flg) res += ", ";
        else flg = true;
        res += to_string(x);
    }
    res += "]";
    return res;
}

#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());
#define SZ(x) ((int)(x).size())

/* range macro. usage: for(int i:range(n)) */
class range {
private:
    struct I {
        int x;
        int operator*() { return x; }
        bool operator!=(I &lhs) { return x < lhs.x; }
        void operator++() { ++x; }
    };
    I i, n;

public:
    range(int n) : i({0}), n({n}) {}
    range(int i, int n) : i({i}), n({n}) {}
    I &begin() { return i; }
    I &end() { return n; }
};

/* keep a max,min */
template <class T>
bool chmax(T &a, const T &b) {
    if(a < b) {
        a = b;
        return 1;
    }
    return 0;
}

template <class T>
bool chmin(T &a, const T &b) {
    if(a > b) {
        a = b;
        return 1;
    }
    return 0;
}

/* input,output operator for pair and vector */
template <typename T1, typename T2>
ostream &operator<<(ostream &os, const pair<T1, T2> &p) {
    os << "(" << p.first << ", " << p.second << ")";
    return os;
}

template <typename T1, typename T2>
istream &operator>>(istream &is, pair<T1, T2> &p) {
    is >> p.first >> p.second;
    return is;
}

template <typename T>
ostream &operator<<(ostream &os, const vector<T> &v) {
    os << "[";
    for(int i = 0; i < (int)v.size(); i++) {
        os << v[i] << (i + 1 != v.size() ? ", " : "");
    }
    os << "]";
    return os;
}

template <typename T>
istream &operator>>(istream &is, vector<T> &v) {
    for(T &in : v) is >> in;
    return is;
}

template <typename T, typename U>
ostream &operator<<(ostream &os, const map<T, U> &mp) {
    for(auto x = mp.begin(); x != mp.end(); ++x) {
        os << x->first << ": " << x->second
           << (x != prev(mp.end()) ? "\n" : "");
    }
    return os;
}

/* initialize vector. usage: auto v = male_v<int>(N,0); */
template <typename T>
vector<T> make_v(size_t a) {
    return vector<T>(a);
}

template <typename T, typename... Ts>
auto make_v(size_t a, Ts... ts) {
    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));
}

/* fill vector. usage: fill_v(v,0); */
template <typename T, typename V>
typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {
    t = v;
}

template <typename T, typename V>
typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {
    for(auto &e : t) fill_v(e, v);
}

/* sum */
template <typename T>
T sum(vector<T> &v) {
    T ret = 0;
    for(T x : v) {
        ret += x;
    }
    return ret;
}
template <typename T>
auto sum(const T &a) {
    return a;
}
template <typename T, typename... A>
auto sum(const T &first, const A &... rest) {
    return sum(first) + sum(rest...);
}

/* mod */
lint intpow(lint a, lint n, lint mod) {
    lint res = 1;
    while(n > 0) {
        if(n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}
template <typename T>
T intpow(T a, lint n) {
    T res = 1;
    while(n > 0) {
        if(n & 1) res = res * a;
        a = a * a;
        n >>= 1;
    }
    return res;
}

long long modinv(long long a, long long m) {
    long long b = m, u = 1, v = 0;
    while(b) {
        long long t = a / b;
        a -= t * b;
        swap(a, b);
        u -= t * v;
        swap(u, v);
    }
    u %= m;
    if(u < 0) u += m;
    return u;
}

/* print */
template <typename T>
void print(const T &first) {
    cout << first << endl;
}
template <typename T, typename... A>
void print(const T &first, const A &... rest) {
    cout << first << " ";
    print(rest...);
}
template <typename... A>
void print(const A &... rest) {
    print(rest...);
}

class BGoldenApple {
public:
    static constexpr int kStressIterations = 0;

    static void generateTest(std::ostream &test) {
    }

    void solve(std::istream &cin, std::ostream &cout) {
        int N, D;
        cin >> N >> D;
        cout << (int) (ceil((double) N / (2 * D + 1))) << endl;
    }
};


int main() {
	BGoldenApple solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
