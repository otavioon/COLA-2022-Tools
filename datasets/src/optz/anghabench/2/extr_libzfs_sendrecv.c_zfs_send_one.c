#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_21__   TYPE_4__ ;
typedef  struct TYPE_20__   TYPE_3__ ;
typedef  struct TYPE_19__   TYPE_2__ ;
typedef  struct TYPE_18__   TYPE_1__ ;

/* Type definitions */
struct TYPE_18__ {int /*<<< orphan*/  zfs_name; int /*<<< orphan*/ * zfs_hdl; } ;
typedef  TYPE_1__ zfs_handle_t ;
struct TYPE_19__ {scalar_t__ verbosity; scalar_t__ backup; scalar_t__ holds; scalar_t__ props; scalar_t__ dedup; scalar_t__ progress; int /*<<< orphan*/  parsable; scalar_t__ dryrun; int /*<<< orphan*/  doall; int /*<<< orphan*/  replicate; int /*<<< orphan*/  raw; } ;
typedef  TYPE_2__ sendflags_t ;
typedef  int /*<<< orphan*/  pthread_t ;
struct TYPE_20__ {int pa_fd; scalar_t__ pa_verbosity; int /*<<< orphan*/  pa_estimate; int /*<<< orphan*/  pa_parsable; TYPE_1__* pa_zhp; int /*<<< orphan*/  member_0; } ;
typedef  TYPE_3__ progress_arg_t ;
typedef  int /*<<< orphan*/  libzfs_handle_t ;
typedef  int /*<<< orphan*/  errbuf ;
struct TYPE_21__ {int /*<<< orphan*/  member_0; } ;
typedef  TYPE_4__ dedup_arg_t ;

/* Variables and functions */
 int /*<<< orphan*/  B_FALSE ; 
 int /*<<< orphan*/  B_TRUE ; 
#define  EACCES 143 
#define  EBUSY 142 
#define  EDQUOT 141 
#define  EFAULT 140 
#define  EFBIG 139 
#define  EIO 138 
#define  ENOENT 137 
#define  ENOLINK 136 
#define  ENOSPC 135 
#define  ENOSTR 134 
#define  ENXIO 133 
#define  EPIPE 132 
#define  ERANGE 131 
#define  EROFS 130 
#define  ESRCH 129 
#define  EXDEV 128 
 int /*<<< orphan*/  EZFS_BADBACKUP ; 
 int /*<<< orphan*/  EZFS_BUSY ; 
 int /*<<< orphan*/  EZFS_CROSSTARGET ; 
 int /*<<< orphan*/  EZFS_CRYPTOFAILED ; 
 int /*<<< orphan*/  EZFS_NOENT ; 
 int /*<<< orphan*/  EZFS_THREADCREATEFAILED ; 
 void* PTHREAD_CANCELED ; 
 int /*<<< orphan*/  TEXT_DOMAIN ; 
 int /*<<< orphan*/  ZFS_TYPE_DATASET ; 
 int /*<<< orphan*/  close (int) ; 
 char* dgettext (int /*<<< orphan*/ ,char*) ; 
 int errno ; 
 int estimate_size (TYPE_1__*,char const*,int,TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,char const*,char*) ; 
 int get_dedup_fd (TYPE_1__*,TYPE_4__*,int,int /*<<< orphan*/ *,int*) ; 
 int /*<<< orphan*/  lzc_exists (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  lzc_flags_from_sendflags (TYPE_2__*) ; 
 int lzc_send_redacted (int /*<<< orphan*/ ,char const*,int,int /*<<< orphan*/ ,char const*) ; 
 int /*<<< orphan*/  pthread_cancel (int /*<<< orphan*/ ) ; 
 int pthread_create (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,TYPE_3__*) ; 
 int /*<<< orphan*/  pthread_join (int /*<<< orphan*/ ,void**) ; 
 int send_conclusion_record (int,int /*<<< orphan*/ *) ; 
 int send_prelim_records (TYPE_1__*,int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ ,scalar_t__,scalar_t__,scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  send_progress_thread ; 
 int /*<<< orphan*/  snapshot_is_before (TYPE_1__*,TYPE_1__*) ; 
 int /*<<< orphan*/  snprintf (char*,int,char*,...) ; 
 scalar_t__ strchr (char const*,char) ; 
 char* strerror (int) ; 
 int /*<<< orphan*/  zfs_close (TYPE_1__*) ; 
 int zfs_error (int /*<<< orphan*/ *,int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  zfs_error_aux (int /*<<< orphan*/ *,char*,...) ; 
 TYPE_1__* zfs_open (int /*<<< orphan*/ *,char const*,int /*<<< orphan*/ ) ; 
 int zfs_standard_error (int /*<<< orphan*/ *,int,char*) ; 

int
zfs_send_one(zfs_handle_t *zhp, const char *from, int fd, sendflags_t *flags,
    const char *redactbook)
{
	int err;
	libzfs_handle_t *hdl = zhp->zfs_hdl;
	int orig_fd = fd;
	pthread_t ddtid, ptid;
	progress_arg_t pa = { 0 };
	dedup_arg_t dda = { 0 };

	char errbuf[1024];
	(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,
	    "warning: cannot send '%s'"), zhp->zfs_name);

	if (from != NULL && strchr(from, '@')) {
		zfs_handle_t *from_zhp = zfs_open(hdl, from,
		    ZFS_TYPE_DATASET);
		if (from_zhp == NULL)
			return (-1);
		if (!snapshot_is_before(from_zhp, zhp)) {
			zfs_close(from_zhp);
			zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
			    "not an earlier snapshot from the same fs"));
			return (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));
		}
		zfs_close(from_zhp);
	}

	/*
	 * Send fs properties
	 */
	if (flags->props || flags->holds || flags->backup) {
		/*
		 * Note: the header generated by send_prelim_records()
		 * assumes that the incremental source is in the same
		 * filesystem/volume as the target (which is a requirement
		 * when doing "zfs send -R").  But that isn't always the
		 * case here (e.g. send from snap in origin, or send from
		 * bookmark).  We pass from=NULL, which will omit this
		 * information from the prelim records; it isn't used
		 * when receiving this type of stream.
		 */
		err = send_prelim_records(zhp, NULL, fd, B_TRUE, B_FALSE,
		    flags->verbosity > 0, flags->dryrun, flags->raw,
		    flags->replicate, flags->backup, flags->holds,
		    flags->props, flags->doall, NULL, NULL);
		if (err != 0)
			return (err);
	}

	/*
	 * Perform size estimate if verbose was specified.
	 */
	if (flags->verbosity != 0) {
		err = estimate_size(zhp, from, fd, flags, 0, 0, 0, redactbook,
		    errbuf);
		if (err != 0)
			return (err);
	}

	if (flags->dryrun)
		return (0);

	/*
	 * If deduplication is requested, spawn a thread that will deduplicate
	 * the data coming out of the kernel.
	 */
	if (flags->dedup) {
		err = get_dedup_fd(zhp, &dda, fd, &ddtid, &fd);
		if (err != 0)
			return (err);
	}

	/*
	 * If progress reporting is requested, spawn a new thread to poll
	 * ZFS_IOC_SEND_PROGRESS at a regular interval.
	 */
	if (flags->progress) {
		pa.pa_zhp = zhp;
		pa.pa_fd = fd;
		pa.pa_parsable = flags->parsable;
		pa.pa_estimate = B_FALSE;
		pa.pa_verbosity = flags->verbosity;

		err = pthread_create(&ptid, NULL,
		    send_progress_thread, &pa);
		if (err != 0) {
			zfs_error_aux(zhp->zfs_hdl, strerror(errno));
			if (flags->dedup) {
				(void) pthread_cancel(ddtid);
				(void) close(fd);
				(void) pthread_join(ddtid, NULL);
			}
			return (zfs_error(zhp->zfs_hdl,
			    EZFS_THREADCREATEFAILED, errbuf));
		}
	}

	err = lzc_send_redacted(zhp->zfs_name, from, fd,
	    lzc_flags_from_sendflags(flags), redactbook);

	if (flags->progress) {
		void *status = NULL;
		if (err != 0)
			(void) pthread_cancel(ptid);
		(void) pthread_join(ptid, &status);
		int error = (int)(uintptr_t)status;
		if (error != 0 && status != PTHREAD_CANCELED) {
			char errbuf[1024];
			(void) snprintf(errbuf, sizeof (errbuf),
			    dgettext(TEXT_DOMAIN, "progress thread exited "
			    "nonzero"));
			return (zfs_standard_error(hdl, error, errbuf));
		}
	}
	if (flags->dedup) {
		if (err != 0)
			(void) pthread_cancel(ddtid);
		(void) close(fd);
		(void) pthread_join(ddtid, NULL);
	}

	if (flags->props || flags->holds || flags->backup) {
		/* Write the final end record. */
		err = send_conclusion_record(orig_fd, NULL);
		if (err != 0)
			return (zfs_standard_error(hdl, err, errbuf));
	}
	if (err != 0) {
		switch (errno) {
		case EXDEV:
			zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
			    "not an earlier snapshot from the same fs"));
			return (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));

		case ENOENT:
		case ESRCH:
			if (lzc_exists(zhp->zfs_name)) {
				zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
				    "incremental source (%s) does not exist"),
				    from);
			}
			return (zfs_error(hdl, EZFS_NOENT, errbuf));

		case EACCES:
			zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
			    "dataset key must be loaded"));
			return (zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf));

		case EBUSY:
			zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,
			    "target is busy; if a filesystem, "
			    "it must not be mounted"));
			return (zfs_error(hdl, EZFS_BUSY, errbuf));

		case EDQUOT:
		case EFBIG:
		case EIO:
		case ENOLINK:
		case ENOSPC:
		case ENOSTR:
		case ENXIO:
		case EPIPE:
		case ERANGE:
		case EFAULT:
		case EROFS:
			zfs_error_aux(hdl, strerror(errno));
			return (zfs_error(hdl, EZFS_BADBACKUP, errbuf));

		default:
			return (zfs_standard_error(hdl, errno, errbuf));
		}
	}
	return (err != 0);
}