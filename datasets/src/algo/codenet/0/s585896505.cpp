/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Gosu_Hiroo
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>
using namespace std;
using ll = long long;

#ifdef int
#define V2(v,size_1, size_2, value) vector<vector<long long>>v(size_1, vector<long long>(size_2, value))
#define V3(v,size_1,size_2,size_3,value) vector<vector<vector<long long>>>v(size_1,vector<vector<long long>>(size_2,vector<long long>(size_1, value)))
#define VI vector<long long>
#define G(g,size_1) vector<vector<long long>>g(size_1, vector<long long>())
#define SZ(x) ((long long)(x).size())
#define VVI  vector<vector<long long>>;
#define VVVI  vector<vector<vector<long long>>>;
#else
#define V2(v,size_1, size_2, value) vector<vector<int>>v(size_1, vector<int>(size_2, value))
#define V3(v,size_1,size_2,size_3,value) vector<vector<vector<int>>>v(size_1,vector<vector<int>>(size_2,vector<int>(size_1, value)))
#define VI vector<int>
#define G(g,size_1) vector<vector<int>>g(size_1, vector<int>())
#define SZ(x) ((int)(x).size())
#define VVI  vector<vector<int>>;
#define VVVI  vector<vector<vector<int>>>;
#endif

#define TR(container, it) \
        for (auto it = container.begin(); it != container.end(); it++)
#define IN(c, x) ((c).find(x) != (c).end())   //O(log n)
#define IN_L(c, x) (find((c).begin(),(c).end(),x) != (c).end()) //O(n)
#define FOR(i, _begin, _end) for (__typeof(_end) end = _end, begin = _begin,  i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))
#define REP(i, end) for (__typeof(end) i = 0, _len = (end); i < (_len); i += 1)
#define ALL(x) (x).begin(),(x).end()
#define SZ(x) ((ll)(x).size())
#define F first
#define S second
#define y0 y3487465
#define y1 y8687969
#define j0 j1347829
#define j1 j234892
#define MOD(x, m) ((((x) % (m)) + (m)) % (m))
#define BIT(n) (1LL<<(n))
#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );
#define READ ({int t;cin >> t;t;})
#define EB emplace_back
#define PB push_back
#define fcout cout << fixed << setprecision(12)
#define fcerr cerr << fixed << setprecision(12)
#define print(x) cout << (x) << endl
# define BYE(a) do { cout << (a) << endl; return ; } while (false)

#ifdef DEBUG
#define ERR(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); _err(cerr,_it, args); }
#define DBG(x) cerr << #x << " is " << x << endl;
#else
#define DBG(x) {};
#define ERR(args...) {};
#endif
void _err(std::ostream& cerr,istream_iterator<string> it) {cerr << endl;}
template<typename T, typename... Args>
void _err(std::ostream& cerr, istream_iterator<string> it, T a, Args... args) {
    cerr << *it << " = " << a << "  ";
    _err(cerr,++it, args...);
}

const double pi = 2 * acos(.0);
const int inf = 0x3f3f3f3f;
const ll mod = (ll) (1e9) + 7;
//const ll mod = (ll) 998244353 ;
const double eps = 1e-10;

template<typename A, size_t N, typename T>
void Fill(A (&array)[N], const T &val) {
    std::fill((T *) array, (T *) (array + N), val);
}


template <typename T>
ostream& operator << (ostream& os, const vector<T> V) {
    os << "[";
    int cnt = 0;
    T curr;
    if(!V.empty()){
        for (int i = 0; i < V.size() - 1; ++i) {
            if(V[i] == curr)cnt ++;
            else cnt = 0;
            if(cnt == 4)os << "... ";
            if(cnt < 4)
                os << V[i] << " ";
            curr = V[i];
        }
        os << V.back();
    }
    os << "]";
    return os;
}

template <typename T, typename U>
ostream& operator << (ostream& os, const pair<T,U> P) {
    os << "(";
    os << P.first << "," << P.second;
    os << ")";
    return os;
}

template <typename T, typename U>
ostream& operator << (ostream& os, const set<T,U> V) {
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for (int i = 0; i < V.size() -1; ++i) {
            os << *it << " ";
            it++;
        }
        os << *it;
    }
    os << "}";
    return os;
}

template <typename K, typename H, typename P>
ostream& operator << (ostream& os, const unordered_set<K, H, P> V) {
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for (int i = 0; i < V.size() -1; ++i) {
            os << *it << " ";
            it++;
        }
        os << *it;
    }
    os << "}";
    return os;
}

template <typename K, typename C>
ostream& operator << (ostream& os, const multiset<K, C> V) {
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for (int i = 0; i < V.size() -1; ++i) {
            os << *it << " ";
            it++;
        }
        os << *it;
    }
    os << "}";
    return os;
}

template <typename K, typename T, typename C>
ostream& operator << (ostream& os, const map<K,T,C> V) {
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for (int i = 0; i < V.size() -1; ++i) {
            os << "(";
            os << it->first << "," << it->second;
            os << ") ";
            it++;
        }
        os << "(";
        os << it->first << "," << it->second;
        os << ")";
    }
    os << "}";
    return os;
}

template <typename K, typename T, typename C>
ostream& operator << (ostream& os, const unordered_map<K,T,C> V) {
    os << "{";
    if(!V.empty()){
        auto it = V.begin();
        for (int i = 0; i < V.size() -1; ++i) {
            os << "(";
            os << it->first << "," << it->second;
            os << ") ";
            it++;
        }
        os << "(";
        os << it->first << "," << it->second;
        os << ")";
    }
    os << "}";
    return os;
}

template <typename T>
ostream& operator << (ostream& os, const deque<T> V) {
    os << "[";
    if (!V.empty()) {
        for (int i = 0; i < V.size() - 1; ++i) {
            os << V[i] << "->";
        }
        if (!V.empty())os << V.back();
    }
    os << "]";
    return os;
};

template <typename T, typename Cont, typename Comp>
ostream& operator << (ostream& os, const priority_queue<T, Cont, Comp> V) {
    priority_queue<T, Cont, Comp> _V = V;
    os << "[";
    if(!_V.empty()){
        while(_V.size() > 1){
            os << _V.top() << "->";
            _V.pop();
        }
        os << _V.top();
    }
    os << "]";
    return os;
};

struct hash_pair {
    template <class T1, class T2>
    size_t operator()(const pair<T1, T2>& p) const
    {
        auto hash1 = hash<T1>{}(p.first);
        auto hash2 = hash<T2>{}(p.second);
        return hash1 ^ hash2;
    }

};

 /*
struct X{
    int x,y,id;
    bool operator < (const X R)const{
        return id < R.id;
    }
    friend ostream& operator << (ostream& os,  X R){
        os << "(" << R.x << "," << R.y << "," << R.id << ")";
    }
    friend bool operator == (const X L,  const X R){
        return L.id == R.id;
    }
*/
template<class T>void Chmod(T &a, const T &m) {a = MOD(a, m);}
template<class T>bool Chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }
template<class T>bool Chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }

#define int ll

class AConnectionAndDisconnection {
public:
    ll f(string t){
        int i = 0, curr = 1, sum = 0;
        if(SZ(t) == 0)return 0;
        while(i < SZ(t)){
            curr = 1;
            while(i < SZ(t) - 1&& t[i] == t[i+1])i++,curr++;
            sum += curr/2;
            i++;
        }
        return sum;
    };
void solve(std::istream& cin, std::ostream& cout, std::ostream& cerr) {
    string s;
    cin >> s;
    int K;
    cin >> K;
//    function<ll(string)> f = [&]
    int ind = 0;
    while(ind < SZ(s) - 1 && s[ind] == s[ind+1])ind++;
    string s_ = s.substr(ind+1) + s.substr(0, ind+1);
    ERR(s_)
    ERR(f(s.substr(ind+1)), f(s.substr(0, ind+1)), f(s_));
    cout << f(s.substr(ind+1)) + f(s.substr(0,ind+1)) + f(s_)*(K-1) << endl;
}


};


#undef int
int main() {

	AConnectionAndDisconnection solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
    std::ostringstream err;
	in.tie(0); ios::sync_with_stdio(0);
//	solver.solve(in, out);
    solver.solve(in, out,err);
	return 0;
}
